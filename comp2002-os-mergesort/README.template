README.template

## Assignment 3 Concurrency 

* Authors: Rachel Chien Wei Lew, Cooper Melville, Humaira Arief Azali
* Group name: Assignment 3 Groups 170

## Overview

Using the pthread library, a multi-threaded version of the merge-sort algorithm will be implemented.
This code will be used to concurrently sort a randomly generated array.

## Manifest

mergesort.c         //contains the code implementation
mergesort.h         //declarations
test-mergesort.c    //tester file
Makefile            //build automation file

## Building the project

To compile using the Makefile, open a terminal and run 'make'

## Features and usage

Summarise the main features of your program. It is also appropriate to
instruct the user how to use your program.

# Features
- merge: This function combines two already sorted subarrays
- my_mergesort: This function splits an array into left and right subarrays and recursively sorts them, before merging
- parallel_mergesort: This function implements the multi-threaded version of mergesort, so it allows subarrays to be sorted concurrently instead of sequentially
- buildArgs: This is a helper function that builds arguments to be used by parallel_mergesort

# Using the program
- After building the project, run the executable test file: ./test-mergesort <input size> <cutoff level> <seed>
- input size: the size of the array
- cutoff level: the number of levels
- seed: initial value used to generate random numbers


## Testing

Ran with the file generated by `make`

Element size in input: 50000000
Seed: 5678
Number of elements sorted: 50000000

Level 0: 8.74 seconds.
Level 1: 4.53 seconds.
Level 2: 2.53 seconds.
Level 3: 1.71 seconds.
Level 4: 1.30 seconds.
Level 5: 1.36 seconds.
Level 6: 1.38 seconds.
Level 7: 1.35 seconds.
Level 8: 1.32 seconds.
Level 9: 1.36 seconds.
Level 10: 1.35 seconds.

Element size in input: 100000000
Seed: 1234
Number of elements sorted: 100000000

Level 0: 17.49 seconds.
Level 1: 9.23 seconds.
Level 2: 5.10 seconds.
Level 3: 3.36 seconds.
Level 4: 2.54 seconds.
Level 5: 2.50 seconds.
Level 6: 2.51 seconds.
Level 7: 2.53 seconds.
Level 8: 2.53 seconds.



Element size in input: 500000000
Seed: 1234
Number of elements sorted: 500000000

Level 0: 93.18 seconds.
Level 1: 21.09 seconds.
Level 2: 27.30 seconds.
Level 3: 45.86 seconds.
Level 4: 14.07 seconds.
Level 5: 12.89 seconds.
Level 6: 12.70 seconds.
Level 7: 13.35 seconds.
Level 8: 13.34 seconds.


Element size in input: 1000000000
Seed: 1234
Number of elements sorted: 1000000000

Level 0: 188.90 seconds.
Level 1: 99.42 seconds.
Level 2: 54.85 seconds.
Level 3: 36.68 seconds.
Level 4: 27.70 seconds.
Level 5: 27.89 seconds.
Level 6: 28.23 seconds.
Level 7: 28.18 seconds.


Element size in input: 5000000000
Seed: 1234
Number of elements sorted: 705032704

Level 0: 163.98 seconds.
Level 1: 71.61 seconds.
Level 2: 38.25 seconds.
Level 3: 25.48 seconds.
Level 4: 18.47 seconds.
Level 5: 18.42 seconds.
Level 6: 18.52 seconds.
Level 7: 18.80 seconds.

Input: ./test-mergesort 2000000000 1 1234
Output: Segmentation fault

Input: ./test-mergesort 3000000000 1 1234
Output: the input size must be at least 2!

Input: ./test-mergesort 4000000000 1 1234
Output: the input size must be at least 2!

For each of the tested input values, performance improved quickly from level 0 to 1, and from level 1 to 2, and performs best with a max level of 4.
Subsequent levels do not provide enough of a performance increase for this amount of data.

Sometimes when running the same test multiple times, there would be outliers in the results. 
For example, when testing with 500000000 elements, there was a result where level 3 took 45.86 seconds to sort the elements,
compared to 27 seconds for level 2, and 14 seconds for level 4.

## Known Bugs

At higher element counts, the program has a segmentation fault or unexpected behaviour,
likely due to the integer limit causing the program to not allocate enough memory and to read integers incorrectly.

Sometimes the printed time result would be incorrect, for example when ./test-mergesort 50000000 8 5678 was ran, it would run with the output
Sorting 50000000 elements took 29.56 seconds
even though the time to output was much shorter than 29 seconds.

## Reflection and Self Assessment

There was a race condition in merge caused by using a global temp array. This is because multiple threads try to write to the same B array at the same time. 
This was fixed by using malloc to assign a local temp array for merging. Each thread now has its own private temp array so there are no shared writes, which eliminates race conditions.

## Sources Used

Arpaci-Dusseau, R.H. and Arpaci-Dusseau, A.C. (2018). OPERATING SYSTEMS : three easy pieces. [online] S.L.: Createspace. Available at: https://pages.cs.wisc.edu/~remzi/OSTEP/.
‌
GeeksforGeeks (2013). Merge Sort Data Structure and Algorithms Tutorials. [online] GeeksforGeeks. Available at: https://www.geeksforgeeks.org/dsa/merge-sort/.
‌
I acknowledge the use of ChatGPT [https://chat.openai.com/] to learn more about the implementation of mergesort. The following prompts were entered into ChatGPT on 26 July 2025:
- How is merge affected if an array is not taken as a parameter?
- Why use a global or local temp array?


If you used any sources outside of the textbook, you should list them here. 
If you looked something up on stackoverflow.com or you use help from AI, and 
fail to cite it in this section, it will be considered plagiarism and dealt 
with accordingly. So be safe CITE!
